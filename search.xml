<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql 不懂的点</title>
      <link href="/2024/02/16/MySql-%E4%B8%8D%E6%87%82%E7%9A%84%E7%82%B9/"/>
      <url>/2024/02/16/MySql-%E4%B8%8D%E6%87%82%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql-不懂的点"><a href="#MySql-不懂的点" class="headerlink" title="MySql 不懂的点"></a>MySql 不懂的点</h1><h2 id="一、安装-mysql（docker）"><a href="#一、安装-mysql（docker）" class="headerlink" title="一、安装 mysql（docker）"></a>一、安装 mysql（docker）</h2><h3 id="以下-MySql-5-7"><a href="#以下-MySql-5-7" class="headerlink" title="以下 MySql 5.7"></a>以下 MySql 5.7</h3><p><strong>方式一 、快捷方式，仅配置root密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>方式二、挂载数据卷</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机创建数据存放目录映射到容器</span></span><br><span class="line">mkdir -p /user_app/mysql5.7/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机创建配置文件目录映射到容器</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">(需要在此目录下创建<span class="string">&quot;conf.d&quot;</span>、<span class="string">&quot;mysql.conf.d&quot;</span>两个目录)</span></span><br><span class="line">mkdir -p /user_app/mysql5.7/conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(建议在此目录创建my.cnf文件并进行相关MySQL配置)</span></span><br><span class="line">mkdir -p /user_app/mysql5.7/conf/conf.d</span><br><span class="line">mkdir -p /user_app/mysql5.7/conf/mysql.conf.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机创建日志目录映射到容器</span></span><br><span class="line">mkdir -p /user_app/mysql5.7/logs</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> CentOS 7 不建议用这个命令</span></span><br><span class="line">docker run --name mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d  -v /usr/local/docker_data/mysql/data:/var/lib/mysql -v /usr/local/docker_data/mysql/conf:/etc/mysql/ -v /usr/local/docker_data/mysql/logs:/var/log/mysql mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">经测试上面这行命令在 CentOS 7 下目录挂载失败。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上面这行命令的基础上增加了 --privileged=<span class="literal">true</span> 参数，让容器拥有真正的root权限</span></span><br><span class="line">docker run --privileged=true --name mysql5.7 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root -d</span><br><span class="line">-v /user_app/mysql5.7/data:/var/lib/mysql</span><br><span class="line">-v /user_app/mysql5.7/conf:/etc/mysql/</span><br><span class="line">-v /user_app/mysql5.7/logs:/var/log/mysql mysql:5.7.30</span><br></pre></td></tr></table></figure><h3 id="以下-MySql-8"><a href="#以下-MySql-8" class="headerlink" title="以下 MySql 8"></a>以下 MySql 8</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行、下载</span></span><br><span class="line">docker run -p 23306:3306 --name mysql8 -e MYSQL_ROOT_PASSWORD=root  -d mysql:8.0.30</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制容器内的文件</span></span><br><span class="line">docker cp  mysql8:/etc/mysql /user_app/mysql8/conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line">docker stop mysql8</span><br><span class="line">docker rm mysql8</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">真正运行</span></span><br><span class="line">sudo docker run -p 23306:3306 --name mysql \</span><br><span class="line">-v /user_app/mysql8/conf:/etc/mysql</span><br><span class="line">-v /user_app/mysql8/log:/var/log \</span><br><span class="line">-v /user_app/mysql8/data:/var/lib/mysql \</span><br><span class="line">-v /user_app/mysql8/lib:/var/lib/mysql-files</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:8.0.30</span><br></pre></td></tr></table></figure><h2 id="二、多版本并发控制-MVCC"><a href="#二、多版本并发控制-MVCC" class="headerlink" title="二、多版本并发控制 MVCC"></a>二、多版本并发控制 MVCC</h2><h3 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h3><h4 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h4><blockquote><p>MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问</p><p>MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有<code>读写冲突</code>时，也能做到<code>不加锁</code>，<code>非阻塞</code>并发读</p></blockquote><h4 id="当前读、快照读和-MVCC-的关系"><a href="#当前读、快照读和-MVCC-的关系" class="headerlink" title="当前读、快照读和 MVCC 的关系"></a>当前读、快照读和 MVCC 的关系</h4><ul><li><strong>当前读</strong></li></ul><p>像 select lock in share mode(共享锁), select for update ; update, insert ,delete (排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的<code>最新版本</code>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行<code>加锁</code>。</p><ul><li><strong>快照读</strong></li></ul><p>像不加锁的 select 操作就是快照读，即<code>不加锁的非阻塞读</code>；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是<code>行锁的一个变种</code>，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并<code>不一定</code>是数据的<code>最新版本</code>，而有<code>可能</code>是之前的<code>历史版本</code>。</p><blockquote><p>快照读：即 MVCC <strong>是为了实现读-写冲突不加锁</strong>，而这个读指的就是<strong>快照读</strong>,</p><p>当前读：而非当前读，当<strong>前读实际上是一种加锁的操作，是悲观锁的实现</strong></p></blockquote><h4 id="能解决什么？好处是？"><a href="#能解决什么？好处是？" class="headerlink" title="能解决什么？好处是？"></a>能解决什么？好处是？</h4><p><strong>数据库并发场景</strong>有三种, 分别为：</p><ul><li><strong>读-读</strong>：不存在任何问题，也不需要并发控制</li><li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><p><strong>好处</strong></p><p>无锁并发控制读写冲突，为事务分配单向增长的<code>时间戳</code>，为每个事务修改保存一个<code>版本</code>，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。</p><p>所以MVCC可以为数据库解决以下问题：</p><p><strong>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</strong></p><p>总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p><ul><li><strong>MVCC + 悲观锁</strong> MVCC解决读写冲突，悲观锁解决写写冲突</li><li><strong>MVCC + 乐观锁</strong> MVCC解决读写冲突，乐观锁解决写写冲突</li></ul><p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p><h3 id="2、实现-MVCC-的原理"><a href="#2、实现-MVCC-的原理" class="headerlink" title="2、实现 MVCC 的原理"></a>2、实现 MVCC 的原理</h3><blockquote><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 <strong>4个隐式字段</strong>、<strong>undo日志</strong>、<strong>Read View</strong> 来实现的。</p></blockquote><h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的 <code>DB_TRX_ID</code>, <code>DB_ROLL_PTR</code> , <code>DB_ROW_ID</code> , <code>DELETED_BIT</code> 等字段</p><ul><li><strong>DB_ROW_ID</strong> 6byte, <code>隐含的自增ID（隐藏主键）</code>，如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li><strong>DB_TRX_ID</strong> 6byte, <code>最近修改(修改/插入)事务ID</code>：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</li><li><strong>DB_ROLL_PTR</strong> 7byte, <code>回滚指针</code>，指向这条记录的上一个版本（存储于rollback segment里）</li><li><strong>DELETED_BIT</strong> 1byte, <code>是否删除的 flag</code>，记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-1.png#id=kIvRy&originHeight=206&originWidth=927&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID 是当前操作该记录的事务ID； 而 DB_ROLL_PTR 是一个回滚指针，用于配合undo 日志，指向上一个旧版本；delete flag没有展示出来。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>InnoDB 把这些为了回滚而记录的这些东西称之为 undo log。这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。undo log主要分为3种：</p><p><strong>Insert undo log</strong> ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</p><p><strong>Update undo log</strong>：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</p><p><strong>Delete undo log</strong>：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。</p><ul><li>删除操作都只是设置一下老记录的 DELETED_BIT，并不真正将过时的记录删除。</li><li>为了节省磁盘空间，InnoDB有专门的 <code>purge（清除）</code> 线程来清理 <code>DELETED_BIT</code> 为 true 的记录。为了不影响 MVCC 的正常工作，purge 线程自己也维护了一个 read view<strong>（这个 read view 相当于系统中最老活跃事务的 read view）</strong>;如果某个记录的 DELETED_BIT 为 true，并且 DB_TRX_ID 相对于 purge 线程的 read view 可见，那么这条记录一定是可以被安全清除的。</li></ul><p>对MVCC有帮助的实质是 <strong>update undo log</strong> ，undo log实际上就是存在rollback segment中旧记录链，它的执行流程如下：</p><p>1、<strong>比如一个有个事务插入persion表插入了一条新记录，记录如下，name为Jerry, age为24岁，隐式主键是1，事务ID和回滚指针，我们假设为NULL</strong></p><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-2.png#id=pNJZp&originHeight=168&originWidth=833&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>2、<strong>现在来了一个事务1对该记录的name做出了修改，改为Tom</strong></p><ol><li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，即在undo log中有当前行的拷贝副本</li><li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，即表示我的上一个版本就是它</li><li>事务提交后，释放锁</li></ol><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-3.png#id=oo5Gy&originHeight=361&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>3、<strong>又来了个事务2修改person表的同一个记录，将age修改为30岁</strong></p><ol><li>在事务2修改该行数据时，数据库也先为该行加锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li><li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li><li>事务提交，释放锁</li></ol><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-4.png#id=pdXYD&originHeight=513&originWidth=838&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的 undo log 成为一条记录版本线性表，即链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该 undo log 的节点可能是会 purge 线程清除掉，像图中的第一条 update undo log，其实在事务提交之后可能就被删除丢失了。</p><h4 id="Read-View（读视图）"><a href="#Read-View（读视图）" class="headerlink" title="Read  View（读视图）"></a>Read  View（读视图）</h4><blockquote><p>什么是 Read View，说白了 Read View 就是事务进行快照读操作的时候生产的读视图( Read View )，在该<code>事务执行的快照读（不加锁的非阻塞读）</code>的那一刻，会生成数据库系统当前的一个快照，记录并维护系统<code>当前活跃事务的ID</code>(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p></blockquote><p>所以我们知道 Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，即可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View 遵循一个可见性算法，主要是将要被修改的数据的最新记录中的 DB_TRX_ID（即<code>当前事务ID，即当前该记录提交的版本</code>）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较，即遍历链表的 DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID, 那么这个 DB_TRX_ID 所在的旧记录就是当前事务能看见的最新老版本。</p><blockquote><p>那么这个判断条件是什么呢？</p></blockquote><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-5.png#id=B70RC&originHeight=632&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>在展示之前，我先简化一下Read View，我们可以把Read View简单的理解成有三个全局属性</p><blockquote><p><strong>trx_list</strong> 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID</p><p><strong>up_limit_id</strong> 记录trx_list列表中事务ID最小的ID</p><p><strong>low_limit_id</strong> ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p></blockquote><ul><li>首先比较DB_TRX_ID &lt; up_limit_id, 如果小于，则当前事务能看到DB_TRX_ID 所在的记录，如果大于等于进入下一个判断</li><li>接下来判断 DB_TRX_ID 大于等于 low_limit_id , 如果大于等于则代表DB_TRX_ID 所在的记录在Read View生成后才出现的，那对当前事务肯定不可见，如果小于则进入下一个判断</li><li>判断DB_TRX_ID 是否在活跃事务之中，trx_list.contains(DB_TRX_ID)，如果在，则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的；如果不在，则说明，你这个事务在Read View生成之前就已经Commit了，你修改的结果，我当前事务是能看见的</li></ul><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>我们在了解了隐式字段，undo log， 以及Read View的概念之后，就可以来看看MVCC实现的整体流程是怎么样了</p><p>整体的流程是怎么样的呢？我们可以模拟一下</p><p>当事务2对某行数据执行了快照读，数据库为该行数据生成一个Read View读视图，假设当前事务ID为2，此时还有事务1和事务3在活跃中，事务4在事务2快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为trx_list</p><table><thead><tr><th>事务1</th><th>事务2</th><th>事务3</th><th>事务4</th></tr></thead><tbody><tr><td>事务开始</td><td>事务开始</td><td>事务开始</td><td>事务开始</td></tr><tr><td>…</td><td>…</td><td>…</td><td>修改且已提交</td></tr><tr><td>进行中</td><td>快照读</td><td>进行中</td><td></td></tr><tr><td>…</td><td>…</td><td>…</td><td></td></tr></tbody></table><p>Read View不仅仅会通过一个列表trx_list来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性up_limit_id（记录trx_list列表中事务ID最小的ID），low_limit_id(记录trx_list列表中下一个事务ID，也就是目前已出现过的事务ID的最大值+1)；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 &#x3D; 5，trx_list集合的值是1,3，Read View如下图</p><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-6.png#id=wVsfE&originHeight=151&originWidth=696&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的undo log如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的DB_TRX_ID去跟up_limit_id,low_limit_id和活跃事务ID列表(trx_list)进行比较，判断当前事务2能看到该记录的版本是哪个。</p><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-7.png#id=GRprN&originHeight=338&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>所以先拿该记录DB_TRX_ID字段记录的事务ID 4去跟Read View的的up_limit_id比较，看4是否小于up_limit_id(1)，所以不符合条件，继续判断 4 是否大于等于 low_limit_id(5)，也不符合条件，最后判断4是否处于trx_list中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本</p><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-8.png#id=i6oQa&originHeight=1141&originWidth=1647&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><h3 id="3、MVCC相关问题"><a href="#3、MVCC相关问题" class="headerlink" title="3、MVCC相关问题"></a>3、MVCC相关问题</h3><h4 id="RR是如何在RC级的基础上解决不可重复读的？"><a href="#RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="RR是如何在RC级的基础上解决不可重复读的？"></a>RR是如何在RC级的基础上解决不可重复读的？</h4><blockquote><p>RR：REPEATABLE READ可重复读</p><p>RC：READ COMMITTED 读已提交</p></blockquote><p>表一：</p><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-9.png"></p><p>表二：</p><p><img src="http://43.139.20.8:9000/learn/db-mysql-mvcc-10.png"></p><p>而在表2这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p><p>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</p><p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p><p><strong>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</strong></p><h4 id="RC-RR级别下的InnoDB快照读有什么不同？"><a href="#RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="RC,RR级别下的InnoDB快照读有什么不同？"></a>RC,RR级别下的InnoDB快照读有什么不同？</h4><p>正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><ul><li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；</li><li>即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见</li><li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li></ul><p><strong>总之在 <strong><code>**RC**</code></strong> 隔离级别下，是每个快照读都会生成并获取</strong><code>**最新的 Read View**</code><strong>；而在 <strong><code>**RR**</code></strong> 隔离级别下，则是同一个事务中的</strong><code>**第一个**</code><strong>快照读才会创建Read View, 之后的快照读获取的都是同一个 Read View</strong>。</p><h2 id="三、使用雪花算法而不用自增ID"><a href="#三、使用雪花算法而不用自增ID" class="headerlink" title="三、使用雪花算法而不用自增ID"></a>三、使用雪花算法而不用自增ID</h2><h3 id="理由"><a href="#理由" class="headerlink" title="理由"></a>理由</h3><ol><li><strong>分布式系统：</strong> 在分布式系统中，多个数据库实例可能同时插入数据，简单的自增ID可能会导致冲突。雪花算法生成的ID包含了时间戳、机器ID和序列号等信息，确保在不同机器上生成的ID不会冲突。</li><li><strong>避免单点瓶颈：</strong> 自增ID通常由数据库维护，而在高并发环境下，数据库的自增ID维护可能成为性能的瓶颈。使用雪花算法，ID的生成可以在应用层完成，避免了对数据库的频繁访问。</li><li><strong>不依赖数据库状态：</strong> 自增ID需要数据库维护一个计数器，而雪花算法生成ID时不依赖数据库的状态。这使得系统更加容错，即使数据库出现问题，ID的生成依然可以进行。</li><li><strong>更好的可扩展性：</strong> 在分布式系统中，如果需要扩展数据库，可能涉及到将数据迁移到新的数据库实例。使用雪花算法生成的ID在不同的数据库实例上不会冲突，使得扩展更加容易。</li></ol><h3 id="数据库自增ID的生成方式"><a href="#数据库自增ID的生成方式" class="headerlink" title="数据库自增ID的生成方式"></a>数据库自增ID的生成方式</h3><p>依赖于数据库内部的计数器，该计数器在表的自增列上逐渐增加，确保每次插入新记录时自增列的值都是唯一的。</p><ol><li><p><strong>计数器：</strong> 数据库内部维护了一个计数器，用于跟踪每个表的自增列的下一个可用值。这个计数器是持久性的，即在数据库关闭和重新启动时也能保持状态。</p></li><li><p><strong>锁机制：</strong> 为了避免并发问题，MySQL使用锁机制来确保在任何时刻只有一个事务能够递增计数器并获取下一个自增ID。这样可以避免多个并发事务同时尝试递增计数器，从而产生相同的自增ID。</p><blockquote><ul><li><strong>表级锁（Table-level Locks）：</strong> 在一些MySQL的存储引擎中，例如MyISAM，表级锁用于保护计数器的递增操作。这意味着在高并发环境下，多个事务不能同时递增同一个表的计数器。</li><li><strong>行级锁（Row-level Locks）：</strong> 在其他存储引擎，例如InnoDB，可以使用行级锁，允许更细粒度的控制。这样在并发插入数据时，不同事务可以同时递增不同行的计数器，减小了锁的争用。</li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webflux 笔记</title>
      <link href="/2024/02/16/webflux%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/16/webflux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="webflux笔记"><a href="#webflux笔记" class="headerlink" title="webflux笔记"></a>webflux笔记</h1><h2 id="Reator-Api"><a href="#Reator-Api" class="headerlink" title="Reator Api"></a>Reator Api</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>得益于 jdk 包的 <code>Flow.class</code>，提供了底层规范，流等于数据（flux、mono）和信号（正常、异常）</p><blockquote><p>Processor：处理器，流式中间的操作，继承了 Publisher，Subscribe</p><p>Publisher：发布者，函数式接口，提供发布的方法</p><p>Subscriber：订阅者，提供订阅消息的生命周期 hook 函数</p><p>Subscription：订阅关系，可对消息订阅进行信号控制，request、cancel 控制流的获取与结束</p></blockquote><p><img src="http://43.139.20.8:9000/learn/image-20240204175643453.png" alt="image-20240204175643453"></p><h3 id="Reator"><a href="#Reator" class="headerlink" title="Reator"></a>Reator</h3><blockquote><p>流：可以规定流的执行，有生命周期的函数 doOnFun</p><p>订阅者：对订阅流的生命周期进行管理，成功、失败的处理</p></blockquote><h2 id="流的理解"><a href="#流的理解" class="headerlink" title="流的理解"></a>流的理解</h2><p>数据在 <code>Reator</code> 以流的形式进行组织</p><blockquote><p>flux：0-N 个元素的流</p><p>mono：0 或 一个元素的流</p></blockquote><p>必须明确的一点，流组织起来，是为了使用的，即被订阅 <code>flux.subscribe(consumer)</code></p><p>在 subscribe 之前什么都不会发生，或者说 subscribe 之前的一切操作都是为了描述这个流（流水线做什么，在 hook 做什么）</p><p><img src="http://43.139.20.8:9000/learn/image-20240204190844382.png" alt="image-20240204190844382"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Processor</span>&lt;T, R&gt; <span class="keyword">extends</span> <span class="title class_">Subscriber</span>&lt;T&gt;, Publisher&lt;R&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Publisher</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> T&gt; s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息订阅者，hook 函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subscriber</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、订阅上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取到消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、发生错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、成功完成</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reator-理解"><a href="#Reator-理解" class="headerlink" title="Reator 理解"></a>Reator 理解</h2><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>作为一个非阻塞的流式框架，他的数据流转是基于事件机制的</p><h3 id="Flux-Api"><a href="#Flux-Api" class="headerlink" title="Flux Api"></a>Flux Api</h3><p>flux api 提供了一些生成数据流的静态方法，那么该流则待处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.just();</span><br><span class="line">Flux.range();</span><br></pre></td></tr></table></figure><p>flux api 提供了一些成员方法，可以处理这些流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会产生新流...</span></span><br><span class="line">filter();</span><br><span class="line">map();</span><br><span class="line"><span class="comment">// 触发事件时执行（hook）...</span></span><br><span class="line">doOnApi();</span><br><span class="line"><span class="comment">// SignalType 信号</span></span><br></pre></td></tr></table></figure><p>通过断点调试，有别于 java8 的 stream api（流需执行完该方法(filter)才会再执行下个方法(peek)），在 Reator 的流被订阅后，方法的断点是被重复执行的，猜测是订阅的数据一个一个被处理的，每次都会从缓冲区只读取一个，处理完才会再读取下一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFluxLog</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux&lt;String&gt; flux = Flux.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            .log()</span><br><span class="line">            .filter(integer -&gt; integer &gt; <span class="number">4</span>)</span><br><span class="line">            .map(integer -&gt; <span class="string">&quot;haha&quot;</span>.concat(integer.toString()));</span><br><span class="line">    flux.subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/image-20240204165500191.png" alt="image-20240204165500191"></p><h3 id="背压：buffer、limitRate"><a href="#背压：buffer、limitRate" class="headerlink" title="背压：buffer、limitRate"></a>背压：buffer、limitRate</h3><p>怎么理解背压，相较于来一个请求数据，就处理一次（正压），背压可利用 <code>buffer</code> 和 <code>limitRate</code> 调整请求的处理速率</p><p><strong>buffer</strong></p><p>积累请求数据到一定数量，才发起一次请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;List&lt;Integer&gt;&gt; flux = Flux.range(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment">//原始流10个</span></span><br><span class="line">        .buffer(<span class="number">3</span>)</span><br><span class="line">        .log();<span class="comment">//缓冲区：缓冲3个元素: 消费一次最多可以拿到三个元素； 凑满数批量发给消费者</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //一次发一个，一个一个发；</span></span><br><span class="line"><span class="comment">// 10元素，buffer(3)；消费者请求4次，数据消费完成</span></span><br></pre></td></tr></table></figure><p><strong>limitRate</strong></p><p>预请求机制，默认 75%，数据请求量到这则立刻请求一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    .log()</span><br><span class="line">    <span class="comment">//限流触发，看上游是怎么限流获取数据的</span></span><br><span class="line">    .limitRate(<span class="number">100</span>) <span class="comment">//一次预取30个元素； 第一次 request(100)，以后request(75)</span></span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><h3 id="编程方式创建序列-sink"><a href="#编程方式创建序列-sink" class="headerlink" title="编程方式创建序列 sink"></a>编程方式创建序列 sink</h3><p>即为以编程方式创建流，两个概念</p><blockquote><p>sink：水槽，存放数据，是一个接口，在生成序列的方法作为对象，必须调用他的 api 去创建</p></blockquote><h4 id="同步：generate"><a href="#同步：generate" class="headerlink" title="同步：generate"></a>同步：generate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SynchronousSink</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">complete</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">Context <span class="title function_">currentContext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> ContextView <span class="title function_">contextView</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放错误</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Throwable e)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">next</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T-实际存放的数据类型（sink 的数据，即流的数据）</span></span><br><span class="line"><span class="comment">// S-信号的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, S&gt; Flux&lt;T&gt; <span class="title function_">generate</span><span class="params">(Callable&lt;S&gt; stateSupplier, BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt; generator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxGenerate</span>&lt;&gt;(stateSupplier, generator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; flux = Flux.generate(() -&gt; <span class="number">0</span>,</span><br><span class="line">        (state, sink) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread());</span><br><span class="line">            sink.next(state);</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">10</span>)&#123;</span><br><span class="line">                sink.complete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">7</span>)&#123;</span><br><span class="line">                sink.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;报错了&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">flux = flux.doOnError(error -&gt; System.out.println(<span class="string">&quot;错了&quot;</span>))</span><br><span class="line">    <span class="comment">// 将错误信号转换成完成信号，可不输出错误信息</span></span><br><span class="line">        .onErrorComplete();</span><br><span class="line"></span><br><span class="line">flux.subscribe(data -&gt; System.out.println(data));</span><br></pre></td></tr></table></figure><h4 id="异步：create"><a href="#异步：create" class="headerlink" title="异步：create"></a>异步：create</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FluxSink</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">FluxSink&lt;T&gt; <span class="title function_">next</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">complete</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Throwable e)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">Context <span class="title function_">currentContext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> ContextView <span class="title function_">contextView</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">requestedFromDownstream</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">FluxSink&lt;T&gt; <span class="title function_">onRequest</span><span class="params">(LongConsumer consumer)</span>;</span><br><span class="line"></span><br><span class="line">FluxSink&lt;T&gt; <span class="title function_">onCancel</span><span class="params">(Disposable d)</span>;</span><br><span class="line"></span><br><span class="line">FluxSink&lt;T&gt; <span class="title function_">onDispose</span><span class="params">(Disposable d)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OverflowStrategy</span> &#123;</span><br><span class="line">IGNORE,</span><br><span class="line">ERROR,</span><br><span class="line">DROP,</span><br><span class="line">LATEST,</span><br><span class="line">BUFFER</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="title function_">create</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> FluxSink&lt;T&gt;&gt; emitter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> create(emitter, OverflowStrategy.BUFFER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyEventListener</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onDataChunk</span><span class="params">(List&lt;T&gt; chunk)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processComplete</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桥接 FluxSink</span></span><br><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">    myEventProcessor.register( </span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MyEventListener</span>&lt;String&gt;() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataChunk</span><span class="params">(List&lt;String&gt; chunk)</span> &#123;</span><br><span class="line">          <span class="keyword">for</span>(String s : chunk) &#123;</span><br><span class="line">            sink.next(s); </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processComplete</span><span class="params">()</span> &#123;</span><br><span class="line">            sink.complete(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="中间处理-：handle"><a href="#中间处理-：handle" class="headerlink" title="中间处理 ：handle"></a>中间处理 ：handle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; Flux&lt;R&gt; <span class="title function_">handle</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, SynchronousSink&lt;R&gt;&gt; handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Fuseable) &#123;</span><br><span class="line">        <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxHandleFuseable</span>&lt;&gt;(<span class="built_in">this</span>, handler));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onAssembly(<span class="keyword">new</span> <span class="title class_">FluxHandle</span>&lt;&gt;(<span class="built_in">this</span>, handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 工作流</title>
      <link href="/2024/02/16/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
      <url>/2024/02/16/git-%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h1><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次克隆代码到本地</span></span><br><span class="line">git <span class="built_in">clone</span> (url)</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . 所有修改过的文件</span><br><span class="line">git add &lt;file&gt; 某文件</span><br></pre></td></tr></table></figure><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase branchName</span><br></pre></td></tr></table></figure><p>相较于 <code>git pull</code>，再合并到当前分支，<code>git rebase</code> 会把新修改的提交指向合并的最后一次提交</p><p>git merge</p><p><img src="http://43.139.20.8:9000/learn/image-20240130151243620.png" alt="image-20240130151243620"></p><p>git rebase</p><p><img src="http://43.139.20.8:9000/learn/image-20240130151351779.png" alt="image-20240130151351779"></p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>git switch</code> 命令只用于分支操作，而 <code>git checkout</code> 命令除了可以切换分支外，还可以用于恢复文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch branchname</span><br></pre></td></tr></table></figure><p>上述命令将当前分支切换为 <code>branchname</code> 分支。如果当前分支有未提交的更改，则 <code>git switch</code> 命令将<strong>拒绝</strong>切换，并提示您在切换分支之前提交或撤消更改。</p><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>储藏工作区的修改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash [push -m <span class="string">&#x27;&#x27;</span>] 储藏修改</span><br><span class="line">git stash pop 弹出并删除最后的一次储藏</span><br><span class="line">git stash list 查看储藏的列表，可查看索引和提交信息</span><br><span class="line">git stash clear 清除所有储藏</span><br><span class="line">git stash apply stash@&#123;index&#125; 合并某次储藏</span><br></pre></td></tr></table></figure><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch 列出本地已经存在的分支，并且当前分支会用*标记</span><br><span class="line">git branch -r 查看远程版本库的分支列表</span><br><span class="line">git branch -a 查看所有分支列表（包括本地和远程，remotes/开头的表示远程分支）</span><br><span class="line">git branch -v 查看一个分支的最后一次提交</span><br><span class="line">git branch --merged  查看哪些分支已经合并到当前分支</span><br><span class="line">git branch --no-merged 查看所有未合并工作的分支</span><br></pre></td></tr></table></figure><h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>区别 switch，checkout 可以恢复文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout branchname 切换分支</span><br><span class="line">git checkout myfile.txt 恢复文件</span><br><span class="line">git checkout mydir/ 恢复目录</span><br></pre></td></tr></table></figure><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>重置（会对分支提交记录进行删除）</p><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>恢复（分支记录不改变，代码会被修改）</p><p>revert是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在，而reset是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD 恢复提交，可指定 commit <span class="built_in">id</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 小总结</title>
      <link href="/2024/02/16/linux-%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2024/02/16/linux-%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="命令与BASH、-PATH"><a href="#命令与BASH、-PATH" class="headerlink" title="命令与BASH、$PATH"></a>命令与BASH、$PATH</h1><p>当你在命令行中输入诸如 <code>ls</code>、<code>ifconfig</code> 等命令时，你实际上在与操作系统的命令行解释器（通常是 Bash 或其他 shell）进行交互。这些命令是在命令行环境中执行的，其效果取决于系统和命令的实际实现。</p><p>下面是为什么这些命令有效的一些基本原因：</p><ol><li><strong>可执行文件：</strong> 这些命令通常是系统上的可执行文件，它们的二进制文件位于系统的标准可执行路径（如 <code>/bin</code>、<code>/usr/bin</code> 等）。当你在命令行中输入命令时，系统会查找这些路径，找到对应的二进制文件，并执行它。</li><li><strong>系统路径：</strong> 操作系统会在系统的环境变量 <code>$PATH</code> 中定义一组路径，用于查找可执行文件。这些路径包括常用的可执行文件目录，以便用户可以在命令行中直接执行这些命令，而无需提供完整的路径。</li><li><strong>命令解释器：</strong> 操作系统使用一个命令解释器来执行用户输入的命令。在大多数 Linux 系统中，默认使用 Bash（Bourne Again SHell）作为命令解释器。Bash能够解释并执行用户输入的命令，包括内置命令和系统可执行文件。</li><li><strong>环境变量：</strong> 命令的可执行路径可以通过系统的环境变量进行配置。<code>$PATH</code> 环境变量定义了系统查找可执行文件的路径。通过查看 <code>$PATH</code>，你可以了解系统将在哪些目录中查找你输入的命令。</li></ol><p>例如，当你输入 <code>ls</code> 时，操作系统会在 <code>$PATH</code> 中定义的目录中查找 <code>ls</code> 可执行文件并执行它。同样，当你输入 <code>ifconfig</code> 时，系统会在 <code>$PATH</code> 中查找 <code>ifconfig</code> 可执行文件。</p><h1 id="YUM（-）"><a href="#YUM（-）" class="headerlink" title="YUM（*）"></a>YUM（*）</h1><p><code>yum</code> 是一种用于在基于 RPM 的 Linux 系统上进行软件包管理的工具。它主要用于自动化软件包的安装、更新和删除操作，并解决软件包之间的依赖关系。有点像前端的 node 管理工具。</p><p><strong>下载目录</strong><br>通常，<code>yum</code> 的默认缓存目录是 <code>/var/cache/yum/</code>。在这个目录下，软件包会按照存储库的结构组织在不同的子目录中。这样，如果你需要重新安装或更新相同的软件包，<code>yum</code> 将会检查缓存目录，如果已经存在相应版本的软件包，就不再需要从网络上重新下载。</p><p>你可以通过查看 <code>yum</code> 配置文件中的 <code>cachedir</code> 设置来确定缓存目录的具体位置。<code>yum</code> 的配置文件通常位于 <code>/etc/yum.conf</code> 或 <code>/etc/yum/yum.conf</code>。</p><p><strong>换源</strong></p><ol><li><p>首先备份系统自带yum源配置文件&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/image-20240115155631991.png" alt="image-20240115155631991"></p></li><li><p>下载国内yum源配置文件到&#x2F;etc&#x2F;yum.repos.d&#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/image-20240115155531989.png" alt="image-20240115155531989"></p></li><li><p>清理yum缓存，并生成新的缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></li><li><p>更新yum源检查是否生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/image-20240115155951814.png" alt="image-20240115155951814"></p></li></ol><p>注：<br>若更新 yum 源不更新内核：<br>直接在 yum 的命令后面加上如下的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --exclude=kernel* update</span><br></pre></td></tr></table></figure><p>国内yum源：<br>阿里yum源:<a href="http://mirrors.aliyun.com/repo/">http://mirrors.aliyun.com/repo/</a><br>163(网易)yum源: <a href="http://mirrors.163.com/.help/">http://mirrors.163.com/.help/</a><br>中科大的Linux安装镜像源：<a href="http://centos.ustc.edu.cn/">http://centos.ustc.edu.cn/</a><br>搜狐的Linux安装镜像源：<a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a><br>北京首都在线科技：<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a></p><h1 id="source-修改-etc-profile-显示命令行目录（-）"><a href="#source-修改-etc-profile-显示命令行目录（-）" class="headerlink" title="source 修改 &#x2F;etc&#x2F;profile 显示命令行目录（*）"></a>source 修改 &#x2F;etc&#x2F;profile 显示命令行目录（*）</h1><p>一般默认系统中查看当前目录，每次都需要pwd指令查看，命令行只显示一层，修改 centos7 中的环境变量 <code>/etc/profile</code>和 <code>/etc/bashrc</code> 可解决此问题</p><ul><li><p>vi &#x2F;etc&#x2F;profile</p><blockquote><p>进入最后一行“shift+g”<br>i进入编辑模式<br>插入<br>export PS1&#x3D;”[\u@\h $PWD]$”</p></blockquote><p><img src="http://43.139.20.8:9000/learn/image-20240115145250539.png" alt="image-20240115145250539"></p><p>之后wq！保存退出，使用 <code>source /etc/profile</code> 使环境变量生效</p></li><li><p>vim &#x2F;etc&#x2F;bashrc</p><blockquote><p>在41行将大写的W ,修改成小写的w<br>之后reboot重启后能看到效果</p></blockquote><p><img src="http://43.139.20.8:9000/learn/image-20240115150038758.png" alt="image-20240115150038758"></p></li></ul><h1 id="etc-profile-文件"><a href="#etc-profile-文件" class="headerlink" title="&#x2F;etc&#x2F;profile 文件"></a>&#x2F;etc&#x2F;profile 文件</h1><p><code>/etc/profile</code> 是一个系统级别的 Bash shell 配置文件，它影响系统上所有用户的 Bash shell 的行为。在 Linux 系统中，这个文件通常用于设置全局的环境变量和执行一些系统范围的初始化任务。</p><p>具体来说，<code>/etc/profile</code> 文件在用户登录时会被执行，用于配置全局的用户环境。它包含了一些全局的 Bash shell 配置，例如：</p><ol><li><strong>环境变量设置：</strong> 在文件中，你可以看到对一些全局环境变量的设置，例如 <code>PATH</code>、<code>PS1</code>（命令行提示符）等。这些设置会影响系统上所有用户的 Bash shell。</li><li><strong>系统级别的命令和别名：</strong> 有时，<code>/etc/profile</code> 中可能包含一些系统级别的命令别名或者函数定义，以提供一些全局性的功能。</li><li><strong>其他初始化任务：</strong> <code>/etc/profile</code> 文件也可以包含其他需要在用户登录时执行的初始化任务，以确保一致的用户环境。</li></ol><p>注意，<code>/etc/profile</code> 文件主要影响 Bash shell。如果用户使用其他 shell（例如 Zsh 或 Fish），这些配置可能不会生效。此外，用户的个人 Bash 配置文件通常是 <code>~/.bashrc</code>，而不是 <code>/etc/profile</code>。</p><h1 id="环境变量及相关文件"><a href="#环境变量及相关文件" class="headerlink" title="环境变量及相关文件"></a>环境变量及相关文件</h1><p>在 <code>/etc/profile</code>：<code>export KEY_NAME=VALUE</code> </p><p>在 <code>/etc/environment</code>: KEY_NAME&#x3D;VALUE</p><p>使用 <code>echo $KEY_NAME</code> 即可取出</p><p>在Linux系统中，与环境变量相关的文件包括：</p><ol><li><strong>&#x2F;etc&#x2F;environment：</strong> 这个文件用于设置系统范围的环境变量。它包含了简单的键值对，每行一个变量定义。</li><li><strong>&#x2F;etc&#x2F;profile：</strong> 这个文件是系统的全局 profile 文件之一，用于在用户登录时执行。在其中可以设置全局的环境变量和执行一些全局的配置。</li><li><strong>&#x2F;etc&#x2F;profile.d&#x2F;：</strong> 这个目录包含了系统范围的 profile 脚本。文件名以<code>.sh</code>结尾的脚本会在用户登录时执行，可以用于设置环境变量等。</li><li><strong><del>&#x2F;.bashrc、</del>&#x2F;.bash_profile、~&#x2F;.profile：</strong> 这些文件是用户级别的Bash shell配置文件，用于在用户登录时执行。你可以在这些文件中设置个别用户的环境变量。</li><li><strong><del>&#x2F;.zshrc、</del>&#x2F;.zprofile：</strong> 如果你使用Zsh作为默认shell，这些文件是用户级别的Zsh shell配置文件，也可用于设置用户的环境变量。</li><li><strong>&#x2F;etc&#x2F;sysconfig：</strong> 在一些发行版如Red Hat系列中，&#x2F;etc&#x2F;sysconfig目录下的文件可以包含系统和服务的配置，有时也包含环境变量的设置。</li><li><strong><del>&#x2F;.bash_logout、</del>&#x2F;.zlogout：</strong> 这些文件是用户退出时执行的Bash或Zsh脚本，通常不用于设置环境变量，但在某些情况下也可以使用。</li></ol><p>当你需要设置或修改环境变量时，可以根据具体的需求选择适当的文件进行编辑。系统范围的变量通常在<code>/etc/environment</code>或<code>/etc/profile.d/</code>中设置，而用户级别的变量可以在用户的<code>~/.bashrc</code>、<code>~/.bash_profile</code>或<code>~/.zshrc</code>等文件中设置。</p><h1 id="VI-常用快捷键"><a href="#VI-常用快捷键" class="headerlink" title="VI 常用快捷键"></a>VI 常用快捷键</h1><table><thead><tr><th align="center">操作</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">shift + g</td><td align="center">快速跳转到最下</td></tr><tr><td align="center">dd</td><td align="center">删一行</td></tr><tr><td align="center">d3g</td><td align="center">从当前行开始删三行</td></tr><tr><td align="center">&#x2F;keyword</td><td align="center">查找</td></tr><tr><td align="center">:数字</td><td align="center">跳转到第几行</td></tr><tr><td align="center">:set number!</td><td align="center">显示行号</td></tr></tbody></table><h1 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h1><h1 id="查看内存空间"><a href="#查看内存空间" class="headerlink" title="查看内存空间"></a>查看内存空间</h1>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优化 sql 建议</title>
      <link href="/2024/02/16/%E4%BC%98%E5%8C%96sql%E5%BB%BA%E8%AE%AE/"/>
      <url>/2024/02/16/%E4%BC%98%E5%8C%96sql%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="后端程序员必备：书写高质量SQL的30条建议"><a href="#后端程序员必备：书写高质量SQL的30条建议" class="headerlink" title="后端程序员必备：书写高质量SQL的30条建议"></a>后端程序员必备：书写高质量SQL的30条建议</h1><h3 id="1、查询SQL尽量不要使用select-，而是select具体字段。"><a href="#1、查询SQL尽量不要使用select-，而是select具体字段。" class="headerlink" title="1、查询SQL尽量不要使用select *，而是select具体字段。"></a>1、查询SQL尽量不要使用select *，而是select具体字段。</h3><p>反例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><p>正例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>只取需要的字段，节省资源、减少网络开销。</li><li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li></ul><h3 id="2、如果知道查询结果只有一条或者只要最大-最小一条记录，建议用limit-1"><a href="#2、如果知道查询结果只有一条或者只要最大-最小一条记录，建议用limit-1" class="headerlink" title="2、如果知道查询结果只有一条或者只要最大&#x2F;最小一条记录，建议用limit 1"></a>2、如果知道查询结果只有一条或者只要最大&#x2F;最小一条记录，建议用limit 1</h3><p>假设现在有employee员工表，要找出一个名字叫jay的人.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employee` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="type">date</span>` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;jay&#x27;</span></span><br></pre></td></tr></table></figure><p>正例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;jay&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li><li>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li></ul><h3 id="3、应尽量避免在where子句中使用or来连接条件"><a href="#3、应尽量避免在where子句中使用or来连接条件" class="headerlink" title="3、应尽量避免在where子句中使用or来连接条件"></a>3、应尽量避免在where子句中使用or来连接条件</h3><p>新建一个user表，它有一个普通索引userId，表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_userId` (`userId`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>假设现在需要查询userid为1或者年龄为18岁的用户，很容易有以下sql</p><p>反例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span><span class="number">18</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>使用<span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者分开两条<span class="keyword">sql</span>写：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>使用or可能会使索引失效，从而全表扫描。</li></ul><blockquote><p>对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程： 全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。 mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。</p></blockquote><h3 id="4、优化limit分页"><a href="#4、优化limit分页" class="headerlink" title="4、优化limit分页"></a>4、优化limit分页</h3><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name，age <span class="keyword">from</span> employee limit <span class="number">10000</span>，<span class="number">10</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>方案一 ：返回上次查询的最大记录(偏移量)</span><br><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">10000</span> limit <span class="number">10.</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方案二：<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">+</span> 索引</span><br><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> employee <span class="keyword">order</span> <span class="keyword">by</span> id  limit <span class="number">10000</span>，<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方案三：在业务允许的情况下限制页数：</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。</li><li>如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。</li><li>方案二使用order by+索引，也是可以提高查询效率的。</li><li>方案三的话，建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</li></ul><h3 id="5、优化你的like语句"><a href="#5、优化你的like语句" class="headerlink" title="5、优化你的like语句"></a>5、优化你的like语句</h3><p>日常开发中，如果用到模糊关键字查询，很容易想到like，但是like很可能让你的索引失效。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userId，name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userId <span class="keyword">like</span> <span class="string">&#x27;%123&#x27;</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userId，name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userId <span class="keyword">like</span> <span class="string">&#x27;123%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>把%放前面，并不走索引，如下：</p><p><img src="http://43.139.20.8:9000/learn/170f7f2739040e5btplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p></li><li><p>把% 放关键字后面，还是会走索引的。如下：</p><p><img src="http://43.139.20.8:9000/learn/170f7f224aa3dfedtplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p></li></ul><h3 id="6、使用where条件限定要查询的数据，避免返回多余的行"><a href="#6、使用where条件限定要查询的数据，避免返回多余的行" class="headerlink" title="6、使用where条件限定要查询的数据，避免返回多余的行"></a>6、使用where条件限定要查询的数据，避免返回多余的行</h3><p>假设业务场景是这样：查询某个用户是否是会员。曾经看过老的实现代码是这样。。。</p><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; userIds = sqlMap.queryList(<span class="string">&quot;select userId from user where isVip=1&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isVip</span> <span class="operator">=</span> userIds.contains(userId);</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> sqlMap.queryObject(<span class="string">&quot;select userId from user where userId=&#x27;userId&#x27; and isVip=&#x27;1&#x27; &quot;</span>)</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isVip</span> <span class="operator">=</span> userId！=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。</li></ul><h3 id="7、尽量避免在索引列上使用mysql的内置函数"><a href="#7、尽量避免在索引列上使用mysql的内置函数" class="headerlink" title="7、尽量避免在索引列上使用mysql的内置函数"></a>7、尽量避免在索引列上使用mysql的内置函数</h3><p>业务需求：查询最近七天内登陆过的用户(假设loginTime加了索引)</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userId,loginTime <span class="keyword">from</span> loginuser <span class="keyword">where</span> Date_ADD(loginTime,<span class="type">Interval</span> <span class="number">7</span> <span class="keyword">DAY</span>) <span class="operator">&gt;=</span>now();</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain  <span class="keyword">select</span> userId,loginTime <span class="keyword">from</span> loginuser <span class="keyword">where</span>  loginTime <span class="operator">&gt;=</span> Date_ADD(NOW(),<span class="type">INTERVAL</span> <span class="operator">-</span> <span class="number">7</span> <span class="keyword">DAY</span>);</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>索引列上使用mysql的内置函数，索引失效</li></ul><p><img src="http://43.139.20.8:9000/learn/170fd5f19265afa9tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><ul><li><p>如果索引列不加内置函数，索引还是会走的。</p><p><img src="http://43.139.20.8:9000/learn/170f875955e8b7c0tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p></li></ul><h3 id="8、应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"><a href="#8、应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫" class="headerlink" title="8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"></a>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="number">-1</span> <span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span><span class="number">11</span>；</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。</p><p><img src="http://43.139.20.8:9000/learn/170f85b4a47dc153tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p></li></ul><h3 id="9、Inner-join-、left-join、right-join，优先使用Inner-join，如果是left-join，左边表结果尽量小"><a href="#9、Inner-join-、left-join、right-join，优先使用Inner-join，如果是left-join，左边表结果尽量小" class="headerlink" title="9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小"></a>9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</h3><blockquote><ul><li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul></blockquote><p>都满足SQL需求的前提下，推荐优先使用Inner join（内连接），如果要使用left join，左边表数据结果尽量小，如果有条件的尽量放到左边处理。</p><p>反例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab1 t1 <span class="keyword">left</span> <span class="keyword">join</span> tab2 t2  <span class="keyword">on</span> t1.size <span class="operator">=</span> t2.size <span class="keyword">where</span> t1.id<span class="operator">&gt;</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab1 <span class="keyword">where</span> id <span class="operator">&gt;</span><span class="number">2</span>) t1 <span class="keyword">left</span> <span class="keyword">join</span> tab2 t2 <span class="keyword">on</span> t1.size <span class="operator">=</span> t2.size;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>如果inner join是等值连接，或许返回的行数比较少，所以性能相对会好一点。</li><li>同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。</li></ul><h3 id="10、应尽量避免在-where-子句中使用-或操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#10、应尽量避免在-where-子句中使用-或操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="10、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>10、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age,name  <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&lt;&gt;</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>可以考虑分开两条<span class="keyword">sql</span>写</span><br><span class="line"><span class="keyword">select</span> age,name  <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&lt;</span><span class="number">18</span>;</span><br><span class="line"><span class="keyword">select</span> age,name  <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>使用!&#x3D;和&lt;&gt;很可能会让索引失效</li></ul><p><img src="http://43.139.20.8:9000/learn/170f8d5a32598527tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><h3 id="11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。"><a href="#11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。" class="headerlink" title="11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。"></a>11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</h3><p>表结构：（有一个联合索引idx_userid_age，userId在前，age在后）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_userid_age` (`userId`,`age`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fabb3abde4936tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>符合最左匹配原则</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> age <span class="operator">=</span><span class="number">10</span>；</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>符合最左匹配原则</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fda546249a690tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p><img src="http://43.139.20.8:9000/learn/170fabd29ed198a8tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>理由：</p><ul><li>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</li><li>联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。</li></ul><h3 id="12、对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描。"><a href="#12、对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描。" class="headerlink" title="12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。"></a>12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> address <span class="operator">=</span><span class="string">&#x27;深圳&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fac5e1650f9b4tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> index idx_address_age (address,age)</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170facab45b2d9a6tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><h3 id="13、如果插入数据过多，考虑批量插入。"><a href="#13、如果插入数据过多，考虑批量插入。" class="headerlink" title="13、如果插入数据过多，考虑批量插入。"></a>13、如果插入数据过多，考虑批量插入。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">User</span> u :list)&#123;</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age) <span class="keyword">values</span>(#name#,#age#)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>一次<span class="number">500</span>批量插入，分批进行</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(name,age) <span class="keyword">values</span></span><br><span class="line"><span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;list&quot; item<span class="operator">=</span>&quot;item&quot; index<span class="operator">=</span>&quot;index&quot; separator<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">    (#&#123;item.name&#125;,#&#123;item.age&#125;)</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>批量插入性能好，更加省时间</li></ul><blockquote><p>打个比喻:假如你需要搬一万块砖到楼顶,你有一个电梯,电梯一次可以放适量的砖（最多放500）,你可以选择一次运送一块砖,也可以一次运送500,你觉得哪个时间消耗大?</p></blockquote><h3 id="14、在适当的时候，使用覆盖索引。"><a href="#14、在适当的时候，使用覆盖索引。" class="headerlink" title="14、在适当的时候，使用覆盖索引。"></a>14、在适当的时候，使用覆盖索引。</h3><p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">like</span>模糊查询，不走索引了</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="keyword">like</span> <span class="string">&#x27;%123%&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fb02be8584b0atplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>id为主键，那么为普通索引，即覆盖索引登场了。</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="keyword">like</span> <span class="string">&#x27;%123%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fafe4a0d3d5e6tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><h3 id="15、慎用distinct关键字"><a href="#15、慎用distinct关键字" class="headerlink" title="15、慎用distinct关键字"></a>15、慎用distinct关键字</h3><p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">from</span>  <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DISTINCT</span> name <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>带distinct的语句cpu时间和占用时间都高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程会占用系统资源，cpu时间。</li></ul><h3 id="16、删除冗余和重复索引"><a href="#16、删除冗余和重复索引" class="headerlink" title="16、删除冗余和重复索引"></a>16、删除冗余和重复索引</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEY `idx_userId` (`userId`)  </span><br><span class="line">KEY `idx_userId_age` (`userId`,`age`)</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引</span><br><span class="line">KEY `idx_userId_age` (`userId`,`age`)</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。</li></ul><h3 id="17、如果数据量较大，优化你的修改-删除语句。"><a href="#17、如果数据量较大，优化你的修改-删除语句。" class="headerlink" title="17、如果数据量较大，优化你的修改&#x2F;删除语句。"></a>17、如果数据量较大，优化你的修改&#x2F;删除语句。</h3><p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，从而影响别人对数据库的访问。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>一次删除<span class="number">10</span>万或者<span class="number">100</span>万<span class="operator">+</span>？</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span><span class="number">100000</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或者采用单一循环操作，效率低，时间漫长</span><br><span class="line"><span class="keyword">for</span>（<span class="keyword">User</span> <span class="keyword">user</span>：list）&#123;</span><br><span class="line">   <span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span>； </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>分批进行删除,如每次<span class="number">500</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">500</span></span><br><span class="line"><span class="keyword">delete</span> product <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">500</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">1000</span>；</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>一次性删除太多数据，可能会有lock wait timeout exceed的错误，所以建议分批操作。</li></ul><h3 id="18、where子句中考虑使用默认值代替null。"><a href="#18、where子句中考虑使用默认值代替null。" class="headerlink" title="18、where子句中考虑使用默认值代替null。"></a>18、where子句中考虑使用默认值代替null。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fbaec810f084ftplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>设置<span class="number">0</span>为默认值</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fbb088234cc77tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>理由：</p><ul><li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</li></ul><blockquote><p>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件<code>！=，&gt;is null，is not null</code>经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。</p></blockquote><ul><li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</li></ul><h3 id="19、不要有超过5个以上的表连接"><a href="#19、不要有超过5个以上的表连接" class="headerlink" title="19、不要有超过5个以上的表连接"></a>19、不要有超过5个以上的表连接</h3><ul><li>连表越多，编译的时间和开销也就越大。</li><li>把连接表拆开成较小的几个执行，可读性更高。</li><li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li></ul><h3 id="20、exist-in的合理利用"><a href="#20、exist-in的合理利用" class="headerlink" title="20、exist &amp; in的合理利用"></a>20、exist &amp; in的合理利用</h3><p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> deptId <span class="keyword">in</span> (<span class="keyword">select</span> deptId <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure><p>这样写等价于：</p><blockquote><p>先查询部门表B</p><p>select deptId from B</p><p>再由部门deptId，查询A的员工</p><p>select * from A where A.deptId &#x3D; B.deptId</p></blockquote><p>可以抽象成这样的一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;&gt; resultSet ;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;B.length;i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;A.length;j++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(A[i].id==B[j].id) &#123;</span><br><span class="line">          resultSet.add(A[i]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> A.deptId <span class="operator">=</span> B.deptId); </span><br></pre></td></tr></table></figure><p>因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p><p>那么，这样写就等价于：</p><blockquote><p>select * from A,先从A表做循环</p><p>select * from B where A.deptId &#x3D; B.deptId,再从B表做循环.</p></blockquote><p>同理，可以抽象成这样一个循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;&gt; resultSet ;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.length;i++) &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;B.length;j++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(A[i].deptId==B[j].deptId) &#123;</span><br><span class="line">          resultSet.add(A[i]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</p><p>因此，我们要选择最外层循环小的，也就是，如果<strong>B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exist</strong>。</p><h3 id="21、尽量用-union-all-替换-union"><a href="#21、尽量用-union-all-替换-union" class="headerlink" title="21、尽量用 union all 替换 union"></a>21、尽量用 union all 替换 union</h3><p>如果检索结果中不会有重复的记录，推荐union all 替换 union。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">union</span>  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1</span> </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span>  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。</li></ul><h3 id="22、索引不宜太多，一般5个以内。"><a href="#22、索引不宜太多，一般5个以内。" class="headerlink" title="22、索引不宜太多，一般5个以内。"></a>22、索引不宜太多，一般5个以内。</h3><ul><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li></ul><h3 id="23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"><a href="#23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型" class="headerlink" title="23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"></a>23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">king_id` <span class="type">varchar</span>（<span class="number">20</span>） <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;守护者Id&#x27;</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`king_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;守护者Id&#x27;</span>`</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li></ul><h3 id="24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。"><a href="#24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。" class="headerlink" title="24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。"></a>24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</h3><p>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p><h3 id="25、尽量避免向客户端返回过多数据量。"><a href="#25、尽量避免向客户端返回过多数据量。" class="headerlink" title="25、尽量避免向客户端返回过多数据量。"></a>25、尽量避免向客户端返回过多数据量。</h3><p>假设业务需求是，用户请求查看自己最近一年观看过的直播数据。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>一次性查询所有数据回来</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> LivingInfo <span class="keyword">where</span> watchId <span class="operator">=</span>useId <span class="keyword">and</span> watchTime <span class="operator">&gt;=</span> Date_sub(now(),<span class="type">Interval</span> <span class="number">1</span> Y)</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>分页查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> LivingInfo <span class="keyword">where</span> watchId <span class="operator">=</span>useId <span class="keyword">and</span> watchTime<span class="operator">&gt;=</span> Date_sub(now(),<span class="type">Interval</span> <span class="number">1</span> Y) limit <span class="keyword">offset</span>，pageSize</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> LivingInfo <span class="keyword">where</span> watchId <span class="operator">=</span>useId <span class="keyword">and</span> watchTime<span class="operator">&gt;=</span> Date_sub(now(),<span class="type">Interval</span> <span class="number">1</span> Y) limit <span class="number">200</span> ;</span><br></pre></td></tr></table></figure><h3 id="26、当在SQL语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。"><a href="#26、当在SQL语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。" class="headerlink" title="26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。"></a>26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">inner</span></span><br><span class="line"><span class="keyword">join</span> B <span class="keyword">on</span> A.deptId <span class="operator">=</span> B.deptId;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  memeber.name,deptment.deptName <span class="keyword">from</span> A <span class="keyword">member</span> <span class="keyword">inner</span></span><br><span class="line"><span class="keyword">join</span> B deptment <span class="keyword">on</span> member.deptId <span class="operator">=</span> deptment.deptId;</span><br></pre></td></tr></table></figure><h3 id="27、尽可能使用varchar-nvarchar-代替-char-nchar。"><a href="#27、尽可能使用varchar-nvarchar-代替-char-nchar。" class="headerlink" title="27、尽可能使用varchar&#x2F;nvarchar 代替 char&#x2F;nchar。"></a>27、尽可能使用varchar&#x2F;nvarchar 代替 char&#x2F;nchar。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`deptName` <span class="type">char</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`deptName` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>因为首先变长字段存储空间小，可以节省存储空间。</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li></ul><h3 id="28、为了提高group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。"><a href="#28、为了提高group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。" class="headerlink" title="28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。"></a>28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> job，avg（salary） <span class="keyword">from</span> employee  <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> job <span class="operator">=</span><span class="string">&#x27;president&#x27;</span> </span><br><span class="line"><span class="keyword">or</span> job <span class="operator">=</span> <span class="string">&#x27;managent&#x27;</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> job，avg（salary） <span class="keyword">from</span> employee <span class="keyword">where</span> job <span class="operator">=</span><span class="string">&#x27;president&#x27;</span> </span><br><span class="line"><span class="keyword">or</span> job <span class="operator">=</span> <span class="string">&#x27;managent&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> job；</span><br></pre></td></tr></table></figure><h3 id="29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效"><a href="#29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效" class="headerlink" title="29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效"></a>29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="operator">=</span><span class="number">123</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fd45766e57cdctplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fd46de786dce3tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p><p>理由：</p><ul><li>为什么第一条语句未加单引号就不走索引了呢？ 这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较。</li></ul><h3 id="30、使用explain-分析你SQL的计划"><a href="#30、使用explain-分析你SQL的计划" class="headerlink" title="30、使用explain 分析你SQL的计划"></a>30、使用explain 分析你SQL的计划</h3><p>日常开发写SQL的时候，尽量养成一个习惯吧。用explain分析一下你写的SQL，尤其是走不走索引这一块。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="operator">=</span><span class="number">10086</span> <span class="keyword">or</span> age <span class="operator">=</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/170fd29c57512897tplv-t2oaga2asx-jj-mark3024000q75.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud 学习笔记</title>
      <link href="/2024/02/06/SpringCloud-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/02/06/SpringCloud-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud-学习笔记"><a href="#SpringCloud-学习笔记" class="headerlink" title="SpringCloud 学习笔记"></a>SpringCloud 学习笔记</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><strong>springcloud</strong></p><ul><li>spring-cloud-starter-openfeign 改进了 feign</li></ul><blockquote><ol><li><strong>对 Spring Cloud 的原生支持：</strong> OpenFeign 是 Spring Cloud 生态系统的一部分，与 Spring Cloud 更紧密地集成。它提供了更好的 Spring Boot 和 Spring Cloud 的原生支持，能够更方便地与其他 Spring Cloud 组件进行集成。</li><li><strong>更好的扩展性：</strong> OpenFeign 提供了更多的扩展点，允许开发者自定义和扩展 Feign 的行为。通过编写自定义的解码器、编码器、拦截器等组件，可以更灵活地定制 HTTP 请求的处理。</li><li><strong>更强大的功能：</strong> OpenFeign 在 Feign 的基础上添加了一些新功能，比如对 HTTP&#x2F;2 的支持、请求和响应压缩、请求重试、延迟配置等功能，使得在实际应用中更加方便和强大。</li><li><strong>性能优化：</strong> OpenFeign 在性能方面也有所优化，对请求和响应的处理做了一些改进，以提高性能和效率。</li><li><strong>更清晰的文档和示例：</strong> OpenFeign 提供了更详细和清晰的文档，对于开发者来说更容易理解和上手。此外，OpenFeign 社区提供了丰富的示例和用法，有助于开发者更好地使用和理解 OpenFeign 的功能。</li></ol></blockquote><blockquote><p>主类</p><p>Feign-Client</p><p>使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(YourApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;your-service-name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">YourFeignClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/your-endpoint&quot;)</span></span><br><span class="line">    String <span class="title function_">yourMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourFeignClient feignClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">yourMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> feignClient.yourMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>spring-cloud-gateway 网关</li></ul><blockquote><p>配置映射的规则</p><p>可以配置文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()</span><br><span class="line">            .route(<span class="string">&quot;your_route_id&quot;</span>, r -&gt; r.path(<span class="string">&quot;/your-path&quot;</span>)</span><br><span class="line">                .uri(<span class="string">&quot;http://your-service-name&quot;</span>))</span><br><span class="line">            <span class="comment">// Add more routes as needed</span></span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># Gateway 端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">your_route_id</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://your-service-name</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/your-path</span></span><br></pre></td></tr></table></figure><ul><li>spring-cloud-starter-loadbalancer 负载均衡器</li></ul><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">yourMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 根据服务负载均衡一个请求 url 字符串</span></span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancer.choose(<span class="string">&quot;your-service-name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">baseUrl</span> <span class="operator">=</span> serviceInstance.getUri().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make your request using RestTemplate</span></span><br><span class="line">        <span class="comment">// Example: restTemplate.getForObject(baseUrl + &quot;/your-endpoint&quot;, String.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Your result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">your-service-name</span></span><br></pre></td></tr></table></figure><p><strong>springcloud-netflix</strong></p><ul><li>spring-cloud-netflix-eureka 注册中心</li><li>spring-cloud-netflix-hystrix 熔断降级</li><li>spring-cloud-netflix-feign 服务调用</li><li>spring-cloud-netflix-ribbon 负载均衡器</li><li>spring-cloud-netflix-zuul 网关</li></ul><p><strong>springcloud-alibaba</strong></p><ul><li>nacos 注册中心</li><li>sentinel 服务治理</li></ul><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p><a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a></p><p>或 REFERENCE 查看 <a href="https://docs.spring.io/spring-cloud/docs/2021.0.5/reference/html/">Spring Cloud</a></p><p><a href="https://sca.aliyun.com/zh-cn/docs/2022.0.0.0/overview/version-explain/">版本发布说明 | Spring Cloud Alibaba (aliyun.com)</a></p><p>主文件依赖，可被子模块继承</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2021.0.1.0<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud-alibaba.version</span>&gt;</span>2021.0.1.0<span class="tag">&lt;/<span class="name">spring-cloud-alibaba.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring-cloud --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring-cloud-alibaba --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="nacos-版本"><a href="#nacos-版本" class="headerlink" title="nacos 版本"></a>nacos 版本</h2><p>Nacos 1.x 和 Nacos 2.x 是 Nacos 服务发现和配置中心的不同版本，它们之间有一些重要的区别：</p><ol><li><strong>架构和性能提升：</strong> Nacos 2.x 引入了基于 Raft 算法的 CP 模式的分布式一致性协议。相比之前的 Nacos 1.x，Nacos 2.x 在架构设计上有了很大的提升，提供了更强大的一致性保证和性能优化。这使得 Nacos 2.x 更加适合于大规模集群、高可用性和强一致性的场景。</li><li><strong>注册中心的改进：</strong> Nacos 2.x 对注册中心进行了优化和改进，提高了注册的稳定性和吞吐量，并且增加了更多的可配置选项，使得 Nacos 2.x 在服务注册和发现方面更加健壮和可靠。</li><li><strong>配置中心的功能增强：</strong> Nacos 2.x 在配置中心方面也进行了功能增强和改进，提供了更多的特性，例如支持更多类型的配置格式、配置变更的推送、动态监听等功能，使得配置管理更加灵活和便捷。</li><li><strong>API 和插件支持：</strong> Nacos 2.x 引入了新的 API，并提供了更多的扩展能力，允许开发者通过插件机制来定制化和扩展 Nacos 的功能，增强了可定制性和灵活性。</li></ol><h3 id="部署-nacos"><a href="#部署-nacos" class="headerlink" title="部署 nacos"></a>部署 nacos</h3><p>修改配置文件</p><blockquote><p>在2.2.0.1和2.2.1版本时，必须执行此变更，否则无法启动；其他版本为建议设置。</p></blockquote><p>修改<code>conf</code>目录下的<code>application.properties</code>文件。</p><p>设置其中的<code>nacos.core.auth.plugin.nacos.token.secret.key</code>值，详情可查看<a href="https://nacos.io/zh-cn/docs/v2/plugin/auth-plugin.html">鉴权-自定义密钥</a>.</p><blockquote><p>注意，文档中的默认值<code>SecretKey012345678901234567890123456789012345678901234567890123456789</code>和<code>VGhpc0lzTXlDdXN0b21TZWNyZXRLZXkwMTIzNDU2Nzg=</code>为公开默认值，可用于临时测试，实际使用时请<strong>务必</strong>更换为自定义的其他有效值。</p></blockquote><p><a href="https://nacos.io/zh-cn/docs/v2/guide/admin/deployment.html">Nacos支持三种部署模式</a></p><p>这里选择单机 nacos 2.1.2 配合 mysql 的方式进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure><h2 id="配置加载顺序"><a href="#配置加载顺序" class="headerlink" title="配置加载顺序"></a>配置加载顺序</h2><h3 id="两个类"><a href="#两个类" class="headerlink" title="两个类"></a>两个类</h3><p><code>ConfigurationPropertiesBindingPostProcessor</code> 和 <code>ConfigFileApplicationListener</code> 在绑定属性的层面有所不同。</p><ol><li><strong>ConfigurationPropertiesBindingPostProcessor：</strong> <ul><li><strong>作用：</strong> 负责将配置文件中的属性值绑定到 Spring 容器中 <code>@ConfigurationProperties</code> 注解所标注的类的属性上。</li><li><strong>绑定方式：</strong> 通过读取配置文件中的属性值，并将其与被 <code>@ConfigurationProperties</code> 注解标注的类的字段或属性进行绑定。</li><li><strong>范围：</strong> 主要关注于将配置文件中的属性绑定到特定的 Java 类上，从而实现属性值与 Java 对象属性的映射。</li></ul></li><li><strong>ConfigFileApplicationListener：</strong> <ul><li><strong>作用：</strong> 负责在应用启动时加载和解析配置文件，并将其属性值绑定到 Spring 的 <code>Environment</code> 中。<code>@Value</code> 注解是用于从 Spring 的 <code>Environment</code> 中获取属性值的一种方式</li><li><strong>绑定方式：</strong> 通过将配置文件中的属性加载到 Spring 的 <code>Environment</code> 对象中，这样在整个应用程序的生命周期内都可以通过 <code>Environment</code> 对象获取属性值。</li><li><strong>范围：</strong> 主要关注于将配置文件中的属性值添加到 Spring 的环境中，这些属性值可以被整个应用程序所使用，不仅限于某个特定的 Java 类。</li></ul></li></ol><h3 id="配置文件的属性赋值到环境对象"><a href="#配置文件的属性赋值到环境对象" class="headerlink" title="配置文件的属性赋值到环境对象"></a>配置文件的属性赋值到环境对象</h3><p>在Spring Boot中，<code>@ConfigurationProperties</code>注解通常用于绑定配置文件中的属性到一个Java Bean上。这些被注解的类会将配置文件中的特定属性绑定到它的字段或者方法参数上。这个绑定过程是通过<code>Binder</code>实现的，它可以将配置文件中的值绑定到Java Bean的属性上。</p><p><code>Environment</code> 是Spring Framework提供的一个接口，它提供了一种统一的访问应用程序配置属性的方式。当Spring Boot应用启动时，它会自动加载配置文件（如<code>application.properties</code>、<code>application.yml</code>），并将这些属性加载到<code>Environment</code>中。</p><p>在使用 <code>@ConfigurationProperties</code> 注解时，Spring Boot 将会从 <code>Environment</code> 中获取已加载的配置属性，并将其映射到相应的 Java Bean 的字段或者属性上。换句话说，<code>@ConfigurationProperties</code> 实际上是利用了 <code>Environment</code> 来获取配置属性值，并将其绑定到特定的 Java Bean 上，而这个 Java Bean 中的属性则被<code>@ConfigurationProperties</code>标记为需要绑定的属性。</p><h3 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h3><p>在 Spring Boot 应用程序启动过程中，<code>SpringApplication</code> 类中的 <code>refreshContext</code> 方法会创建并刷新应用程序的上下文。在这个过程中，会初始化 <code>Environment</code> 对象，并在 <code>SpringApplication</code> 中进行属性的加载。</p><p>具体的加载属性到 <code>Environment</code> 的过程涉及到 <code>PropertySources</code> 的管理，这些源包括了不同的属性来源，例如命令行参数、系统属性、环境变量以及配置文件中的属性。<code>PropertySources</code> 负责管理这些属性，<code>SpringApplication</code> 在初始化过程中会将这些属性加载到 <code>Environment</code> 对象中。</p><p>配置文件的加载主要通过 <code>PropertySourceLoader</code> 接口的实现类来完成，其中常用的是 <code>YamlPropertySourceLoader</code> 和 <code>PropertiesPropertySourceLoader</code>。这些加载器会根据配置文件的格式将配置信息加载到 <code>Environment</code> 中，例如 YAML 格式的配置文件会使用 <code>YamlPropertySourceLoader</code> 来加载。</p><p><img src="http://43.139.20.8:9000/learn/image-20231228212545851.png#id=NufHR&originHeight=107&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="http://43.139.20.8:9000/learn/image-20231228195240336.png#id=lzJhW&originHeight=633&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="五、服务注册和发现-Nacos-注册中心-配置中心"><a href="#五、服务注册和发现-Nacos-注册中心-配置中心" class="headerlink" title="五、服务注册和发现 Nacos 注册中心 配置中心"></a>五、服务注册和发现 Nacos 注册中心 配置中心</h2><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p><img src="http://43.139.20.8:9000/learn/image-20240110181234097.png#id=Xqkfh&originHeight=475&originWidth=886&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ruoyi-auth</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 环境配置</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 服务注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">ZhengZhou</span>             <span class="comment"># 集群名称，配置为相同集群可关联访问优先级</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="number">123</span>  <span class="comment"># 命名空间，不同命名空间下的服务不能互相访问，逻辑上隔开</span></span><br></pre></td></tr></table></figure><p><strong>三个角色</strong></p><ul><li>服务提供者：提供服务接口被调用</li><li>服务消费者：调用服务提供的接口</li><li>注册中心：记录服务的信息（服务名、调用地址端口）</li></ul><p><strong>消费者获取提供者地址</strong></p><p>从注册中心拉取服务的实例信息（可能有多个），可通过负载均衡算法返回一个合适的服务实例以供请求。</p><p><strong>消费者如何得知服务状态变更</strong></p><p>服务提供者通过心跳机制报告自己的状态，注册中心会把异常的服务实例剔除，并通知订阅了该服务的消费者</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bootstrap.yaml</span></span><br><span class="line"><span class="attr">server:</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ruoyi-auth</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 环境配置</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment"># 服务注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">ZhengZhou</span>             <span class="comment"># 集群名称，配置为相同集群可关联访问优先级</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="number">123</span>  <span class="comment"># 命名空间，不同命名空间下的服务不能互相访问，逻辑上隔开</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment"># 配置中心地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment"># 配置文件格式</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span></span><br><span class="line">        <span class="comment"># 共享配置</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">application-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="number">123</span><span class="comment"># 不同命名空间的配置不一样，这里可以空间名或ID可以</span></span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/image-20240110195948795.png#id=UY9lk&originHeight=834&originWidth=1880&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="http://43.139.20.8:9000/learn/image-20240110195948795.png#id=wl8AY&originHeight=834&originWidth=1880&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p><img src="http://43.139.20.8:9000/learn/image-20240110193245752.png#id=Hxn76&originHeight=291&originWidth=596&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="六、服务调用和负载均衡-OpenFeign-LoadBalancer"><a href="#六、服务调用和负载均衡-OpenFeign-LoadBalancer" class="headerlink" title="六、服务调用和负载均衡 OpenFeign LoadBalancer"></a>六、服务调用和负载均衡 OpenFeign LoadBalancer</h2><p>注册中心提供了服务实例的注册信息，可通过openfeign的依赖拉取服务实力列表简化调用，可通过loadbalancer的依赖实现服务调用的负载均衡服务调用openfeign</p><h3 id="openfeign-的创建"><a href="#openfeign-的创建" class="headerlink" title="openfeign 的创建"></a>openfeign 的创建</h3><p>通过注解，feign 会代理该接口的方法，在其他 bean 进行引用就好了，代理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(contextId = &quot;remoteUserService&quot;, value = ServiceNameConstants.SYSTEM_SERVICE, fallbackFactory = RemoteUserFallbackFactory.class,url = &quot;https://www.csdn.net&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RemoteUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/test/feign&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;?&gt; testFeign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>debug 调试</strong></p><p>1、该代理对象，就是 <code>FeignCachingInvocationHandlerFactory</code> 创建的匿名代理对象（InvocationHandler）</p><p><img src="http://43.139.20.8:9000/learn/image-20240116145704508.png" alt="image-20240116145704508"></p><p>2、执行该代理方法，就相当于执行 <code>delegateFactory.create(target, dispatch);</code> 创建的授权代理器 <code>SentinelInvocationHandler</code> 代为执行</p><p><img src="http://43.139.20.8:9000/learn/image-20240116150827669.png" alt="image-20240116150827669"></p><p><img src="http://43.139.20.8:9000/learn/image-20240116150703938.png" alt="image-20240116150703938"></p><p>3、最后执行到这 <code>SynchronousMethodHandler</code>，可以看出是跟负载均衡的 <code>loadbalancer</code> 是有点关系的</p><p><img src="http://43.139.20.8:9000/blog/image-20240116152840992.png" alt="image-20240116152840992"></p><p><img src="http://43.139.20.8:9000/learn/image-20240116152804316.png" alt="image-20240116152804316"></p><p>4、进来看看 <code>FeignBlockingLoadBalancerClient</code>，最后 debug 到 <code>RoundRobinLoadBalancer</code>，默认是轮询</p><p><img src="http://43.139.20.8:9000/blog/image-20240116155829004.png" alt="image-20240116155829004"></p><p>默认在这发的请求 <code>LoadBalancerUtils.executeWithLoadBalancerLifecycleProcessing</code></p><p><img src="http://43.139.20.8:9000/learn/image-20240116160129010.png" alt="image-20240116160129010"></p><blockquote><p>总结：可支持 HttpClient、okhttp连接池替代原生的发请求，即便注册中心挂了一段时间，他还是能通过 loadbalancer 缓存的实例请求负载均衡请求。</p></blockquote><h3 id="FeignClient-的-url-属性"><a href="#FeignClient-的-url-属性" class="headerlink" title="@FeignClient 的 url 属性"></a>@FeignClient 的 url 属性</h3><p>不通过负载均衡，直接请求该 url ，不在乎设置的服务</p><h3 id="fallbackFactory"><a href="#fallbackFactory" class="headerlink" title="fallbackFactory"></a>fallbackFactory</h3><p>报错会回调的工厂</p><h3 id="连接池配置"><a href="#连接池配置" class="headerlink" title="连接池配置"></a>连接池配置</h3><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>写配置</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置：FeignClient、EnableFeignClient 上的范围区别</p><p>局部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><p>全局</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>抽成公共模块，每个服务都是一个小模块，把他们的数据、实体、远程调用 feign、fallbackfactory都写进该模块，最后让其他微服务依赖于此模块即可</p><p><img src="http://43.139.20.8:9000/learn/image-20240116185432346.png" alt="image-20240116185432346"></p><h2 id="七、服务网关-GateWay"><a href="#七、服务网关-GateWay" class="headerlink" title="七、服务网关 GateWay"></a>七、服务网关 GateWay</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong>id</strong>：唯一即可</p><p><strong>url</strong>：<strong>lb</strong> 不是协议，而是相当于一个标识，让 loadbalancer 进行负载均衡uri</p><p><strong>predicates</strong>：断言，判断当前请求是否符合规则，符合则路由到目标服务，可在官网文档查看断言工厂</p><p><strong>filters 路径重写</strong>：过滤器，从功能上，有许多内置过滤器，从范围上，有网关过滤器、默认过滤器、全局过滤器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><p>服务重定向</p><h3 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h3><p>这算是最常见的断言工厂</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/code/**</span></span><br></pre></td></tr></table></figure><h3 id="filter（【内置、自定义】网关过滤器、默认过滤器、全局过滤器）"><a href="#filter（【内置、自定义】网关过滤器、默认过滤器、全局过滤器）" class="headerlink" title="filter（【内置、自定义】网关过滤器、默认过滤器、全局过滤器）"></a>filter（【内置、自定义】网关过滤器、默认过滤器、全局过滤器）</h3><p><img src="http://43.139.20.8:9000/learn/image-20240122162527155.png" alt="image-20240122162527155"></p><p>官网：<a href="https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/gatewayfilter-factories.html">GatewayFilter Factories :: Spring Cloud Gateway</a></p><p><strong>自定义网关过滤器</strong></p><blockquote><p>该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！则可在配置文件使用该过滤器用前缀即可</p><p>路径重写过滤器</p><p>- RewritePath&#x3D;&#x2F;red&#x2F;?(?&lt;segment&gt;.*), &#x2F;${segment}</p><p>**&#x2F;?(?&lt;segment&gt;.*)**：&#x2F;?代表&#x2F;可有可无，?&lt;segment&gt;.*代表固定官方写法?开始捕获段，.* 正则任意字符0或多个</p><p>**&#x2F;$\{segment}**：捕获到重写，$\{segment}官方不和yaml冲突，$\{}取值</p></blockquote><p>写过滤器（extends AbstractGatewayFilterFactory&lt;T&gt; ），在配置文件使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LearnGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Learn</span></span><br></pre></td></tr></table></figure><blockquote><p>前提，spring.cloud.gateway.discovery.locator.enabled&#x3D;true 必须是 false，否则自定义网关普通过滤器不能被加载</p><p>该配置是开启服务发现定位器开关，true 则可不编写路由规则，注册到服务中心即可通过默认的方式去访问该服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">与服务注册与发现组件结合，设置为 true 后；id默认为微服务名称xxx-server；gatewayapplication有feign自动做负载均衡;</span><br><span class="line">不需要定制化显式配置；已生成默认的id=xservice,uri: lb://xserver , path=/serviceId/**</span><br></pre></td></tr></table></figure><p>配置为 false 则参照配置的路由规则</p></blockquote><p><strong>自定义全局过滤器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGloableFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> </span><br></pre></td></tr></table></figure><p><strong>顺序</strong></p><p>从下图可知，default &gt; common &gt; gloable</p><p><img src="http://43.139.20.8:9000/learn/image-20240123151338291.png" alt="image-20240123151338291"></p><h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p><img src="http://43.139.20.8:9000/learn/image-20240122153640451.png" alt="image-20240122153640451"></p><h1 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h1><p>阿里开发的 Druid 是一个<code>开源</code>的<code>数据库连接池</code>和<code>监控组件</code>。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/alibaba/druid">alibaba&#x2F;druid: 阿里云计算平台DataWorks(https://help.aliyun.com/document_detail&#x2F;137663.html) 团队出品，为监控而生的数据库连接池 (github.com)</a></p><p><a href="https://developer.aliyun.com/article/1157595">Spring Boot 整合 Druid 指南-阿里云开发者社区 (aliyun.com)</a></p><h1 id="项目配置不可缺"><a href="#项目配置不可缺" class="headerlink" title="项目配置不可缺"></a>项目配置不可缺</h1><p>1、点击 maven 刷新按钮，会更改 jdk 版本，可配置该插件进行固定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、mysql 驱动不可少，使用该包可通用配置，该包出自 <code>spring-boot-dependencies</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、bootstrap.yaml 识别</p><p>作为启动加载的配置文件，似乎得有 springcloud-context 的环境才会被 idea 识别到，导入以下任何依赖都会被识别到</p><p><img src="http://43.139.20.8:9000/learn/image-20240104155033259.png#id=ibvS1&originHeight=327&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册中心客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://43.139.20.8:9000/learn/image-20240104155141453.png#id=zMaqN&originHeight=322&originWidth=457&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h1 id="开启项目"><a href="#开启项目" class="headerlink" title="开启项目"></a>开启项目</h1><h2 id="组件安装"><a href="#组件安装" class="headerlink" title="组件安装"></a>组件安装</h2><p><strong>docker redis:6.2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -p 6379:6379 --name learn-chat-redis -d redis:6.2</span><br></pre></td></tr></table></figure><p>整合两套 swagger 管理系统</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
